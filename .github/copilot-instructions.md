````instructions
<!-- Autogenerated guidance for AI coding agents working on this repo -->
# Copilot / AI agent instructions — PythonProjectManager

Purpose
- Brief: CLI utility to manage Python virtual environments with auto-detection of system Python installations. Configured interpreter paths are stored in `.pynstal/interpreters.json` and templates in `.pynstal/templates.json`.

Big picture
- Main components:
  - `create_venv.py`: creates virtual environments and installs packages via subprocess; returns (success, stdout, stderr).
  - `handle_data.py`: `InterpretersData` dataclass that reads/writes `.pynstal/interpreters.json` and exposes `interpreters_data` singleton.
  - `main.py`: Full CLI with subcommands for interpreter management, venv creation, and template management.
  - Interpreter detection: Scans Windows (pyenv-win, AppData, common paths), Unix (/usr/bin, /usr/local/bin, pyenv, conda) for Python installations.
- Data flow: interpreter paths persisted in `.pynstal/interpreters.json`; templates in `.pynstal/templates.json`. CLI accessible via `pynstal` console script entry point.

CLI Subcommands (see `main()` parser)
- `pynstal add-interpreter <path>`: Manually add interpreter path to .pynstal/interpreters.json
- `pynstal list`: Show configured interpreters and global interpreter
- `pynstal interpreter detect [--add | --add-all]`: Auto-detect system Python installations; optionally add to config
  - `--add`: Interactive selection (user picks which to add)
  - `--add-all`: Add all detected without confirmation
- `pynstal create-venv <interpreter> <venv_dir> [--dry-run]`: Create virtual environment
- `pynstal create-from-template <template> <venv_dir> [--interpreter <path>] [--dry-run]`: Create venv and install template packages
- `pynstal template list/show/add/remove/add-complex`: Manage package install templates

Key conventions & patterns (repo-specific)
- Working dir: runtime assumes repository root as CWD so `.pynstal/` resolves correctly — run commands from repo root.
- Python version: uses modern typing (e.g., `list[str]`, type hints) so target Python >= 3.10.
- Environment detection: `detect_interpreters()` returns list of dicts `{'path': str, 'version': str}`. Platform-aware scanning functions (`_scan_windows_python()`, `_scan_unix_python()`, `_scan_conda_envs()`, `_scan_pyenv()`) contribute candidates to a set, then `_get_python_version()` verifies executability and extracts version.
- Data format: `.pynstal/interpreters.json` with keys `interpreters` (list) and `global_interpreter`. Example:
  ```json
  {
    "FILE_PATH": "interpreters.json",
    "interpreters": ["C:\\Users\\...\\python.exe", "..."],
    "global_interpreter": null
  }
  ```
  `.pynstal/templates.json` format: `{"templates": {"name": [...] or {"packages": [...], "args": [...]}}}` supporting both simple (list) and complex (dict with args) package specifications.
- Subprocess behavior: `_create_venv()` calls Python with `-m venv` via `subprocess.Popen(..., shell=True)`. On Windows this can affect quoting and path handling. Prefer using absolute interpreter paths and test commands locally.
- Version extraction: `_get_python_version()` runs `python --version` with 5s timeout and strips "Python " prefix from output.

How to run / reproduce actions (discoverable commands)
- Auto-detect Python environments:
  ```powershell
  pynstal interpreter detect          # List found interpreters
  pynstal interpreter detect --add    # Interactive: select which to add
  pynstal interpreter detect --add-all # Add all without confirmation
  ```
- Create a venv with first detected interpreter:
  ```powershell
  pynstal create-venv "C:\\path\\to\\python.exe" my_venv
  pynstal create-venv "C:\\path\\to\\python.exe" my_venv --dry-run  # Preview only
  ```
- Manage templates:
  ```powershell
  pynstal template list                                        # Show all
  pynstal template add mytemplate "numpy scipy"               # Simple packages
  pynstal template add-complex pytorch "torch torchvision" --args-str "--index-url https://..." # With pip args
  pynstal create-from-template pytorch my_venv                # Create venv and install
  ```

Important codenotes for agents editing code
- When modifying `detect_interpreters()` or related scan functions:
  - Ensure `_scan_windows_python()` handles both relative paths (legacy data) and absolute paths (new detections)
  - `_scan_conda_envs()` checks for existence of conda root before listdir; guards against missing directories
  - `_get_python_version()` catches all exceptions and returns None on failure; detection continues for remaining candidates
  - Platform detection uses `sys.platform == "win32"` for Windows vs Unix behavior (e.g., Scripts/python.exe vs bin/python)
- When modifying `handle_data.InterpretersData.save()`: keep `DATA_DIR` and relative file paths behavior intact — tests and user data expect `.pynstal/` folder.
- Be careful changing subprocess invocation in `create_venv.py`: `shell=True` is present and affects how the argument list is interpreted on Windows. If you replace it, verify venv creation works on Windows and that `stdout`/`stderr` are captured correctly.
- `interpreters_data.interpreters` may be `None` — guard reads accordingly (see `create_venv()` check).
- Templates can be either strings (simple list) or dicts (with "packages" and "args" keys); handle both formats when iterating.

Files to inspect for examples
- `main.py`: Detection logic (`detect_interpreters()` and `_scan_*()` helpers), `cmd_interpreter_detect()` CLI handler, argparse subcommand registration
- `create_venv.py`: venv creation and subprocess return shape, package installation with optional pip args
- `handle_data.py`: data persistence and runtime semantics
- `.pynstal/interpreters.json`: canonical example of persisted interpreter paths
- `.pynstal/templates.json`: example template definitions (bundled resource fallback in `pythonprojectmanager/templates.json`)

If unclear or incomplete
- When adding new detection sources (e.g., new conda variants, virtual env locations): update appropriate `_scan_*()` function and test on both Windows and Unix
- If environment detection misses a location: check for directory existence before listdir (avoid errors), verify `_get_python_version()` handles the executable correctly
- If subprocess calls fail on Windows: ensure absolute paths (not relative), test with shell=True in isolation, check stderr for access/quoting issues

Feedback request
- After applying changes, ask the maintainer what intended workflows (CLI flags, GUIs, integration with editors) they expect `main.py` to implement.

-- End of guidance

````
<!-- Autogenerated guidance for AI coding agents working on this repo -->
# Copilot / AI agent instructions — PythonProjectManager

Purpose
- Brief: CLI utility to manage Python virtual environments with auto-detection of system Python installations. Configured interpreter paths are stored in `data/interpreters.json` and templates in `data/templates.json`.

Big picture
- Main components:
  - `create_venv.py`: creates virtual environments and installs packages via subprocess; returns (success, stdout, stderr).
  - `handle_data.py`: `InterpretersData` dataclass that reads/writes `data/interpreters.json` and exposes `interpreters_data` singleton.
  - `main.py`: Full CLI with subcommands for interpreter management, venv creation, and template management.
  - Interpreter detection: Scans Windows (pyenv-win, AppData, common paths), Unix (/usr/bin, /usr/local/bin, pyenv, conda) for Python installations.
- Data flow: interpreter paths persisted in `data/interpreters.json`; templates in `data/templates.json`. CLI accessible via `ppm` console script entry point.

CLI Subcommands (see `main()` parser)
- `ppm add-interpreter <path>`: Manually add interpreter path to data/interpreters.json
- `ppm list`: Show configured interpreters and global interpreter
- `ppm interpreter detect [--add | --add-all]`: Auto-detect system Python installations; optionally add to config
  - `--add`: Interactive selection (user picks which to add)
  - `--add-all`: Add all detected without confirmation
- `ppm create-venv <interpreter> <venv_dir> [--dry-run]`: Create virtual environment
- `ppm create-from-template <template> <venv_dir> [--interpreter <path>] [--dry-run]`: Create venv and install template packages
- `ppm template list/show/add/remove/add-complex`: Manage package install templates

Key conventions & patterns (repo-specific)
- Working dir: runtime assumes repository root as CWD so `data/` resolves correctly — run commands from repo root.
- Python version: uses modern typing (e.g., `list[str]`, type hints) so target Python >= 3.10.
- Environment detection: `detect_interpreters()` returns list of dicts `{'path': str, 'version': str}`. Platform-aware scanning functions (`_scan_windows_python()`, `_scan_unix_python()`, `_scan_conda_envs()`, `_scan_pyenv()`) contribute candidates to a set, then `_get_python_version()` verifies executability and extracts version.
- Data format: `data/interpreters.json` with keys `interpreters` (list) and `global_interpreter`. Example:
  ```json
  {
    "FILE_PATH": "interpreters.json",
    "interpreters": ["C:\\Users\\...\\python.exe", "..."],
    "global_interpreter": null
  }
  ```
  `data/templates.json` format: `{"templates": {"name": [...] or {"packages": [...], "args": [...]}}}` supporting both simple (list) and complex (dict with args) package specifications.
- Subprocess behavior: `_create_venv()` calls Python with `-m venv` via `subprocess.Popen(..., shell=True)`. On Windows this can affect quoting and path handling. Prefer using absolute interpreter paths and test commands locally.
- Version extraction: `_get_python_version()` runs `python --version` with 5s timeout and strips "Python " prefix from output.

How to run / reproduce actions (discoverable commands)
- Auto-detect Python environments:
  ```powershell
  ppm interpreter detect          # List found interpreters
  ppm interpreter detect --add    # Interactive: select which to add
  ppm interpreter detect --add-all # Add all without confirmation
  ```
- Create a venv with first detected interpreter:
  ```powershell
  ppm create-venv "C:\path\to\python.exe" my_venv
  ppm create-venv "C:\path\to\python.exe" my_venv --dry-run  # Preview only
  ```
- Manage templates:
  ```powershell
  ppm template list                                        # Show all
  ppm template add mytemplate "numpy scipy"               # Simple packages
  ppm template add-complex pytorch "torch torchvision" --args-str "--index-url https://..." # With pip args
  ppm create-from-template pytorch my_venv                # Create venv and install
  ```

Important codenotes for agents editing code
- When modifying `detect_interpreters()` or related scan functions:
  - Ensure `_scan_windows_python()` handles both relative paths (legacy data) and absolute paths (new detections)
  - `_scan_conda_envs()` checks for existence of conda root before listdir; guards against missing directories
  - `_get_python_version()` catches all exceptions and returns None on failure; detection continues for remaining candidates
  - Platform detection uses `sys.platform == "win32"` for Windows vs Unix behavior (e.g., Scripts/python.exe vs bin/python)
- When modifying `handle_data.InterpretersData.save()`: keep `DATA_DIR` and relative file paths behavior intact — tests and user data expect `data/` folder.
- Be careful changing subprocess invocation in `create_venv.py`: `shell=True` is present and affects how the argument list is interpreted on Windows. If you replace it, verify venv creation works on Windows and that `stdout`/`stderr` are captured correctly.
- `interpreters_data.interpreters` may be `None` — guard reads accordingly (see `create_venv()` check).
- Templates can be either strings (simple list) or dicts (with "packages" and "args" keys); handle both formats when iterating.

Files to inspect for examples
- `main.py`: Detection logic (`detect_interpreters()` and `_scan_*()` helpers), `cmd_interpreter_detect()` CLI handler, argparse subcommand registration
- `create_venv.py`: venv creation and subprocess return shape, package installation with optional pip args
- `handle_data.py`: data persistence and runtime semantics
- `data/interpreters.json`: canonical example of persisted interpreter paths
- `data/templates.json`: example template definitions (bundled resource fallback in `pythonprojectmanager/templates.json`)

If unclear or incomplete
- When adding new detection sources (e.g., new conda variants, virtual env locations): update appropriate `_scan_*()` function and test on both Windows and Unix
- If environment detection misses a location: check for directory existence before listdir (avoid errors), verify `_get_python_version()` handles the executable correctly
- If subprocess calls fail on Windows: ensure absolute paths (not relative), test with shell=True in isolation, check stderr for access/quoting issues

Feedback request
- After applying changes, ask the maintainer what intended workflows (CLI flags, GUIs, integration with editors) they expect `main.py` to implement.

-- End of guidance
